#!/usr/bin/env python3
import os
import subprocess
import yaml
import argparse

BASE_DIR = "/tmp/qemu-compose"


def ensure_dirs():
    os.makedirs(BASE_DIR, exist_ok=True)
    os.makedirs(f"{BASE_DIR}/logs", exist_ok=True)


def load_yaml(path):
    with open(path, "r") as f:
        return yaml.safe_load(f)


def kvm_available():
    return os.path.exists("/dev/kvm")


def build_qemu_command(name, conf):
    arch = conf.get("arch", "x86_64")
    machine = conf.get("machine", "q35")
    cpus = conf.get("cpus", 2)
    cpu_model = conf.get("cpu_model", "max")  # safe default
    memory = conf.get("memory", 2048)
    cpu_max_speed = conf.get("cpu_max_speed", 100)  # percentage (1-100)

    # Detect KVM
    if arch == "x86_64" and kvm_available():
        accel = "kvm"
        cpu_model = "host"
    else:
        accel = "tcg"  # fallback

    cmd = [
        f"qemu-system-{arch}",
        "-accel", accel,
        "-machine", machine,
        "-smp", str(cpus),
        "-m", str(memory),
        "-cpu", cpu_model,
        "-display", "gtk",
    ]

    # ------------------------
    # CPU SPEED LIMITING
    # ------------------------
    if cpu_max_speed < 100:
        # Calculate icount shift based on percentage
        # Lower percentage = higher shift = slower execution
        # shift=auto with sleep provides throttling
        shift = max(0, int(7 - (cpu_max_speed / 100.0) * 7))
        cmd += ["-icount", f"shift={shift},sleep=on"]
        print(f"CPU throttled to {cpu_max_speed}% (icount shift={shift})")

    # ------------------------
    # NETWORKS
    # ------------------------
    net_id = 0
    if "networks" in conf:
        for net in conf["networks"]:
            net_id += 1
            net_type = net.get("type", "user")
            mac = net.get("mac", f"52:54:00:{net_id:02x}:{net_id:02x}:{net_id:02x}")
            
            # Build netdev based on type
            if net_type == "user":
                # User mode networking (NAT with port forwarding)
                forwards = net.get("forwards", [])
                fwd_str = ",".join(
                    [f"hostfwd=tcp::{f['host_port']}-:{f['guest_port']}" for f in forwards]
                )
                
                netdev = f"user,id=net{net_id}"
                if fwd_str:
                    netdev += f",{fwd_str}"
                
                # Apply network conditions for user mode
                conditions = net.get("conditions", {})
                if "latency" in conditions:
                    # Note: QEMU user mode has limited condition support
                    print(f"⚠️  Network conditions on user mode are limited")
                
                cmd += [
                    "-netdev", netdev,
                    "-device", f"virtio-net-pci,netdev=net{net_id},mac={mac}"
                ]
            
            elif net_type == "tap":
                # TAP networking (requires bridge setup on host)
                ifname = net.get("ifname", f"tap{net_id}")
                bridge = net.get("bridge", None)
                script = net.get("script", "no")
                downscript = net.get("downscript", "no")
                
                netdev = f"tap,id=net{net_id},ifname={ifname},script={script},downscript={downscript}"
                if bridge:
                    netdev += f",br={bridge}"
                
                cmd += [
                    "-netdev", netdev,
                    "-device", f"virtio-net-pci,netdev=net{net_id},mac={mac}"
                ]
                print(f"TAP network: {ifname}" + (f" on bridge {bridge}" if bridge else ""))
            
            elif net_type == "socket":
                # Socket networking for VM-to-VM communication
                mode = net.get("mode", "server")  # server or client
                path = net.get("path", f"/tmp/qemu-net{net_id}.sock")
                
                if mode == "server":
                    netdev = f"socket,id=net{net_id},listen={path}"
                    print(f"Socket server: {path}")
                else:  # client
                    netdev = f"socket,id=net{net_id},connect={path}"
                    print(f"Socket client: {path}")
                
                cmd += [
                    "-netdev", netdev,
                    "-device", f"virtio-net-pci,netdev=net{net_id},mac={mac}"
                ]
            
            elif net_type == "vlan":
                # VLAN networking
                vlan_id = net.get("vlan_id", 1)
                parent = net.get("parent", "user")
                
                # Create parent network first, then tag with VLAN
                netdev = f"{parent},id=net{net_id},vlan={vlan_id}"
                
                cmd += [
                    "-netdev", netdev,
                    "-device", f"virtio-net-pci,netdev=net{net_id},mac={mac}"
                ]
                print(f"VLAN {vlan_id} network")
            
            elif net_type == "multicast":
                # Multicast socket networking
                mcast_addr = net.get("address", "230.0.0.1:1234")
                
                netdev = f"socket,id=net{net_id},mcast={mcast_addr}"
                
                cmd += [
                    "-netdev", netdev,
                    "-device", f"virtio-net-pci,netdev=net{net_id},mac={mac}"
                ]
                print(f"Multicast network: {mcast_addr}")
            
            # Apply network conditions (if supported)
            conditions = net.get("conditions", {})
            if conditions and net_type in ["socket", "tap"]:
                cond_parts = []
                if "latency" in conditions:
                    cond_parts.append(f"latency: {conditions['latency']}")
                if "packet_loss" in conditions:
                    cond_parts.append(f"loss: {conditions['packet_loss']}%")
                if "bandwidth" in conditions:
                    cond_parts.append(f"bandwidth: {conditions['bandwidth']}")
                
                if cond_parts:
                    print(f"  Network conditions: {', '.join(cond_parts)}")
                    print(f"  ⚠️  Note: Apply conditions on host using 'tc netem' for tap{net_id}")


    # ------------------------
    # DISKS
    # ------------------------
    if "disks" in conf:
        for d in conf["disks"]:
            path = d["path"]
            fmt = d.get("format", "qcow2")
            iface = d.get("interface", "virtio")
            cmd += ["-drive", f"file={path},format={fmt},if={iface}"]

    # ------------------------
    # CDROM / ISO
    # ------------------------
    if "cdrom" in conf:
        iso_path = conf["cdrom"]["path"]
        interface = conf["cdrom"].get("interface", "ide")
        cmd += ["-drive", f"file={iso_path},media=cdrom,if={interface}"]

    # ------------------------
    # MONITOR SOCKET
    # ------------------------
    monitor_path = f"{BASE_DIR}/{name}.monitor"
    cmd += ["-monitor", f"unix:{monitor_path},server=on,wait=off"]

    return cmd


def start_vm(name, conf):
    ensure_dirs()
    cmd = build_qemu_command(name, conf)
    log_file = f"{BASE_DIR}/logs/{name}.log"

    print(f"Starting {name} ...")
    print(" ".join(cmd))

    with open(log_file, "w") as lf:
        process = subprocess.Popen(cmd, stdout=lf, stderr=lf)

    print(f"{name} started (pid={process.pid}) logs -> {log_file}")


def stop_vm(name):
    monitor_path = f"{BASE_DIR}/{name}.monitor"
    if not os.path.exists(monitor_path):
        print("VM not running or monitor socket missing.")
        return

    try:
        subprocess.run(
            ["socat", "-", f"unix-connect:{monitor_path}"],
            input="system_powerdown\n",
            text=True
        )
        print(f"{name} stopped.")
    except FileNotFoundError:
        print("Install socat: sudo apt install socat")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["up", "down"])
    parser.add_argument("-f", "--file", default="qemu-compose.yml")
    args = parser.parse_args()

    data = load_yaml(args.file)
    vms = data.get("vms", {})

    for name, conf in vms.items():
        if args.action == "up":
            start_vm(name, conf)
        elif args.action == "down":
            stop_vm(name)


if __name__ == "__main__":
    main()
